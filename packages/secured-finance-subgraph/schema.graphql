type Loan @entity {
  id: ID!
  lender: Bytes!
  lenderUser: User!
  borrower: Bytes!
  borrowUser: User!
  currencyIdentifier: Bytes!
  currency: Currency!
  term: BigInt!
  notional: BigInt!
  couponPayment: BigInt!
  rate: BigInt!
  startTimestamp: BigInt!
  endTimestamp: BigInt!
  presentValue: BigInt!
  currentTimestamp: BigInt!
  isAvailable: Boolean!
  startTxHash: Bytes!
  state: Int!

  schedule: LoanSchedule! @derivedFrom(field: "loan")
  termination: LoanTermination @derivedFrom(field: "loan")
  novationHistory: [LoanNovation!] @derivedFrom(field: "loan")
}

type LoanSchedule @entity {
  id: ID!

  payments: [SchedulePayment!]! @derivedFrom(field: "schedule")
  loan: Loan!
}

type LoanTermination @entity {
  id: ID!
  terminationAsker: Bytes!
  terminationSubmitter: Bytes!
  terminationDate: BigInt!
  repayment: BigInt!
  loan: Loan!
}

type LoanNovation @entity {
  id: ID!
  previousLender: Bytes!
  newLender: Bytes!
  novationDate: BigInt!
  loan: Loan!
}

type SchedulePayment @entity {
  id: ID!
  notice: BigInt!
  payment: BigInt!
  amount: BigInt!
  isDone: Boolean!
  txHash: Bytes!

  schedule: LoanSchedule!
}

enum LoanState {
  REGISTERED
  WORKING
  DUE
  PAST_DUE
  CLOSED
  TERMINATED
}

type User @entity {
  id: ID!
  owner: Bytes!
  totalLendInETH: BigInt!
  totalBorrowInETH: BigInt!
  # totalCollateralInETH: BigInt!

  updatedAt: BigInt!

  # collateral: Collateral! @derivedFrom(field: "user")
  loans: [Loan!]! @derivedFrom(field: "lenderUser")
  borrows: [Loan!] @derivedFrom(field: "borrowUser")

  closedLoans: [Loan!]! @derivedFrom(field: "lenderUser")
  closedBorrows: [Loan!] @derivedFrom(field: "borrowUser")

  openOrders: [LendingMarketOrder!] @derivedFrom(field: "makerUser")

  madeOrders: [FilledLendingMarketOrder!] @derivedFrom(field: "makerUser")
  takenOrders: [FilledLendingMarketOrder!] @derivedFrom(field: "takerUser")
  # canceledOrders: [LendingMarketOrder!] @derivedFrom(field: "makerUser")

  crosschainAddresses: [CrosschainAddress!] @derivedFrom(field: "user")
}

type LendingMarketController @entity {
  id: ID!

  # liquidity
  totalAvailableLiquidityETH: BigInt!
  totalLiquidityETH: BigInt!

  totalAvailableLiquidityFIL: BigInt!
  totalLiquidityFIL: BigInt!

  totalAvailableLiquidityBTC: BigInt!
  totalLiquidityBTC: BigInt!

  totalAvailableLiquidityUSDC: BigInt!
  totalLiquidityUSDC: BigInt!

  # liquidity in USD
  totalAvailableLiquidityInUSD: BigInt!
  totalLiquidityInUSD: BigInt!

  markets: [LendingMarket!] @derivedFrom(field: "controller")
  marketCount: Int!
}

type LendingMarket @entity {
  id: ID!
  marketAddr: Bytes!
  controller: LendingMarketController!
  currencyIdentifier: Bytes!
  currency: Currency!
  term: BigInt!
  spread: BigInt!
  marketRate: BigInt!
  orderCount: Int!

  # liquidity
  totalAvailableLiquidity: BigInt!
  totalLiquidity: BigInt!

  # liquidity in USD
  totalAvailableLiquidityInUSD: BigInt!
  totalLiquidityInUSD: BigInt!

  # creation timestamps
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!

  # two-sided orderbook
  lendOrderbook: [LendingMarketOrderRow!] @derivedFrom(field: "lendMarket")
  borrowOrderbook: [LendingMarketOrderRow!] @derivedFrom(field: "borrowMarket")

  lendOrders: [LendingMarketOrder!] @derivedFrom(field: "lendingMarket")
  borrowOrders: [LendingMarketOrder!] @derivedFrom(field: "borrowingMarket")
  canceledOrders: [LendingMarketOrder!] @derivedFrom(field: "cancelMarket")

  tradeHistory: [FilledLendingMarketOrder!] @derivedFrom(field: "market")
}

type LendingMarketOrderRow @entity {
  id: ID!
  currencyIdentifier: Bytes!
  currency: Currency!
  side: Int!
  marketAddr: Bytes!
  lendMarket: LendingMarket!
  borrowMarket: LendingMarket!
  term: BigInt!
  rate: BigInt!
  orders: [LendingMarketOrder!] @derivedFrom(field: "row")
  totalAmount: BigInt!
  # totalUSDAmount: BigInt!

  # creation timestamps
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
}

type LendingMarketOrder @entity {
  id: ID!
  orderId: BigInt!
  currencyIdentifier: Bytes!
  currency: Currency!
  side: Int!
  row: LendingMarketOrderRow
  marketAddr: Bytes!
  lendingMarket: LendingMarket
  borrowingMarket: LendingMarket
  cancelMarket: LendingMarket
  term: BigInt!
  rate: BigInt!
  amount: BigInt!
  deadline: BigInt!
  maker: Bytes!
  makerUser: User!

  # creation timestamps
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!

  # # updated timestamps
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

type FilledLendingMarketOrder @entity {
  id: ID!
  orderId: BigInt!
  currencyIdentifier: Bytes!
  currency: Currency!
  side: Int!
  market: LendingMarket!
  marketAddr: Bytes!
  term: BigInt!
  rate: BigInt!
  amount: BigInt!
  maker: Bytes!
  makerUser: User!
  taker: Bytes!
  takerUser: User!

  # creation timestamps
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
}

type Term @entity {
  id: ID!
  daysNum: BigInt!
  dfFrac: BigInt!
  paymentNum: BigInt!

  products: [Product!]! @derivedFrom(field: "terms")
  currencies: [Currency!]! @derivedFrom(field: "terms")
}

type Product @entity {
  id: ID!
  prefix: Bytes!
  productImplementation: Bytes!
  productController: Bytes!
  terms: [Term!]!
}

type Currency @entity {
  id: ID!
  identifier: Bytes!
  name: String!
  shortName: String!
  chainID: Int!
  ltv: BigInt!
  minMargin: BigInt!
  isSupported: Boolean!
  isCollateral: Boolean!
  terms: [Term!]!

  priceFeed: PriceFeed! @derivedFrom(field: "currency")
}

type PriceFeed @entity {
  id: ID!
  contract: Bytes!
  currency: Currency!
  pair: String!
}

type CloseOutNetting @entity {
  id: ID!
  address0: Bytes!
  address1: Bytes!
  addresses: String!
  packedAddresses: Bytes!
  aggregatedPayment0: BigInt!
  aggregatedPayment1: BigInt!
  netPayment: BigInt!
  currency: Currency!
  flipped: Boolean!
}

type TimeSlot @entity {
  id: ID!
  address0: Bytes!
  address1: Bytes!
  addresses: String!
  totalPayment0: BigInt!
  totalPayment1: BigInt!
  netPayment: BigInt!
  paidAmount: BigInt!

  year: BigInt!
  month: BigInt!
  day: BigInt!
  position: Bytes!
  flipped: Boolean!
  isSettled: Boolean!
  currency: Currency!

  paymentConfirmations: [TimeSlotPaymentConfirmation!]
    @derivedFrom(field: "timeslot")
}

type TimeSlotPaymentConfirmation @entity {
  id: ID!
  timeslot: TimeSlot!
  settlementId: Bytes!
  payer: Bytes!
  receiver: Bytes!
  amount: BigInt!
  settledAt: BigInt!
}

type CollateralAggregator @entity {
  id: ID!
  address: Bytes!
  liquidationPrice: BigInt!
  marginCall: BigInt!
  autoLiquidation: BigInt!
  minCollateralRequirements: BigInt!
  collateralPositions: [CollateralPosition!] @derivedFrom(field: "aggregator")
  bilateralPositions: [BilateralPosition!] @derivedFrom(field: "aggregator")
  collateralVaults: [CollateralVault!] @derivedFrom(field: "aggregator")
  collateralUserContracts: [CollateralUserContract!]
    @derivedFrom(field: "aggregator")
}

type CollateralPosition @entity {
  id: ID!
  address: Bytes!
  isRegistered: Boolean!
  user: User!
  aggregator: CollateralAggregator!
  collateralPositions: [CollateralPositionCurrencyState!]
    @derivedFrom(field: "position")
}

type CollateralPositionCurrencyState @entity {
  id: ID!
  address: Bytes!
  unsettledPV: BigInt!
  currencyIdentifier: Bytes!
  currency: Currency!
  user: User!
  aggregator: CollateralAggregator!
  position: CollateralPosition!
}

type BilateralPosition @entity {
  id: ID!
  address0: Bytes!
  address1: Bytes!
  addresses: String!
  packedAddresses: Bytes!
  collateralNettings: [CollateralNetting!]
    @derivedFrom(field: "bilateralPosition")
  aggregator: CollateralAggregator!
}

type CollateralNetting @entity {
  id: ID!
  address0: Bytes!
  address1: Bytes!
  addresses: String!
  currencyIdentifier: Bytes!
  currency: Currency!
  packedAddresses: Bytes!
  unsettled0PV: BigInt!
  unsettled1PV: BigInt!
  party0PV: BigInt!
  party1PV: BigInt!
  netPV: BigInt!
  aggregator: CollateralAggregator!
  bilateralPosition: BilateralPosition!
}

type CollateralVault @entity {
  id: ID!
  address: Bytes!
  currency: Currency!
  currencyIdentifier: Bytes!
  tokenAddress: Bytes!
  collateralBooks: [CollateralBook!] @derivedFrom(field: "vault")
  collateralPositions: [CollateralVaultPosition!] @derivedFrom(field: "vault")
  aggregator: CollateralAggregator!
  isSupported: Boolean!
}

type CollateralUserContract @entity {
  id: ID!
  address: Bytes!
  aggregator: CollateralAggregator!
  isSupported: Boolean!
}

type CollateralBook @entity {
  id: ID!
  address: Bytes!
  user: User!
  currency: Currency!
  currencyIdentifier: Bytes!
  independentCollateral: BigInt!
  lockedCollateral: BigInt!
  vault: CollateralVault!
  isDefaulted: Boolean!
}

type CollateralVaultPosition @entity {
  id: ID!
  address0: Bytes!
  address1: Bytes!
  addresses: String!
  packedAddresses: Bytes!
  currency: Currency!
  currencyIdentifier: Bytes!
  vault: CollateralVault!
  lockedCollateral0: BigInt!
  lockedCollateral1: BigInt!
}

type CrosschainAddress @entity {
  id: ID!
  ethAddress: Bytes!
  user: User!
  chainID: BigInt!
  address: String!
}

type CrosschainSettlementRequest @entity {
  id: ID!
  payer: Bytes!
  crosschainPayerAddress: String!
  payerUser: User!
  receiver: Bytes!
  crosschainReceiverAddress: String!
  receiverUser: User!
  chainId: Int!
  timestamp: BigInt!
  createdAt: BigInt!
  settledAt: BigInt!
  amount: BigInt!
  txHash: String!
  settlementId: Bytes!
  requestId: Bytes!
  paymentConfirmation: TimeSlotPaymentConfirmation!
}
